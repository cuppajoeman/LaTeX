priority 1

# Math Context
global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C',
'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS',
'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(
            i for i in reversed(synstackids)
            if i in texIgnoreMathZoneIds or i in texMathZoneIds
        )
		return first != ignore
	except StopIteration:
		return False
endglobal

global !p
def create_matrix(snip):

        matrix_str = (snip.buffer[snip.line].split('mat')[0]+'matrix').strip()

        rows = 'x'.join(snip.buffer[snip.line].split("x", 2)[:-1])
        cols = 'x'.join(snip.buffer[snip.line].split("x", 2)[-1:])

        int_val = lambda string: int(''.join(s for s in string if s.isdigit()))

        rows = int_val(rows)
        cols = int_val(cols)

        offset = cols + 1
        old_spacing = snip.buffer[snip.line][:snip.buffer[snip.line].rfind('\t') + 1]

        snip.buffer[snip.line] = ''

        final_str = old_spacing + "\\begin{"+matrix_str+"} $1\n"

        for i in range(rows):
                final_str += old_spacing + '\t'
                final_str += " & ".join(['$' + str(i * cols + j + offset + 1) for j in range(cols)])

                final_str += " \\\\\\\n"

        final_str = final_str[:-4] + '\n'

        final_str += old_spacing + "\\end{"+matrix_str+"}"

        snip.expand_anon(final_str)

endglobal

global !p
def create_inline_matrix(snip):

        until = int(snip.cursor[1])
        rest = snip.buffer[snip.line][until:]
        given_i = snip.buffer[snip.line][0:until].rfind('i') 
        given = snip.buffer[snip.line][given_i:until]

        # I don't think we'll be dealing with matricies over 1 digit in size...
        rows = int(given.split("x", 2)[0][-1])
        cols = int(given.split("x", 2)[-1][0])

        offset = cols + 1

        snip.buffer[snip.line] = snip.buffer[snip.line][0:until - 7] 

        final_str = "\\mat{"

        for i in range(rows):
                final_str += ' '
                final_str += " & ".join(['$' + str(i * cols + j + offset) for j in range(cols)])
                final_str += " \\\\\\"

        final_str = final_str[:-3] +  "}$0"
        final_str += rest

        snip.expand_anon(final_str)

endglobal

global !p
def test(snip):

        until = int(snip.cursor[1])
        rest = snip.buffer[snip.line][until:]
        given_i = snip.buffer[snip.line][0:until].rfind('i') 
        given = snip.buffer[snip.line][given_i:until]

        snip.buffer[snip.line] = snip.buffer[snip.line][0:until - 7] 

        final_str = '$0the snippet $1 $2 $3' + rest

        snip.expand_anon(final_str)

endglobal


#     e    e                  d8   888            ,d88~~\   d8              88~\   88~\
#    d8b  d8b       /~~~8e  _d88__ 888-~88e       8888    _d88__ 888  888 _888__ _888__
#   d888bdY88b          88b  888   888  888       `Y88b    888   888  888  888    888
#  / Y88Y Y888b    e88~-888  888   888  888        `Y88b,  888   888  888  888    888
# /   YY   Y888b  C888  888  888   888  888          8888  888   888  888  888    888
#/          Y888b  "88_-888  "88_/ 888  888       \__88P'  "88_/ "88_-888  888    888

snippet mm "Math" wA
$${1:${VISUAL}}$`!p
punctuation = t[2] and t[2][0] in [',', '.', '?', '-']
if punctuation:
	if len(t[2]) == 1:
	  t[2] = t[2] + (' ' if t[2][0] in [',', '.', '?'] else '')
	snip.rv=''
else:
	snip.rv=' '
`$2
endsnippet

snippet dm "Math" wA
\[
${1:${VISUAL}}
\]
$0
endsnippet

snippet eq "Equation" b
\begin{equation}
	$0
\end{equation}
endsnippet

snippet eqnn "Equation without number" b
\begin{equation*}
	$0
\end{equation*}
endsnippet

snippet prf "Proof" b
\begin{proof}
	$ $\newline
	${1:${VISUAL}}
\end{proof}
endsnippet

snippet dprf "Proof" b
\begin{disproof}
	$ $\newline
	${1:${VISUAL}}
\end{disproof}
endsnippet

snippet prfbind "Proof by induction" b
\begin{proof}
	$ $\newline
	\begin{itemize}
		\item \textbf{Base Case:}\\\\
			We show that $P(${1:0})$ holds, we know $2
		\item \textbf{Induction Step:}\\\\
			Let $k \in \mathbb{N}$ and assume that $P(k)$ holds, that is $3
			We'll show that $P(k + 1)$ holds, so we must show that $4
			We know $5
	\end{itemize}
	Thus by the principle of induction we have proven the original statement.
\end{proof}
endsnippet

snippet al "Align" b
\begin{align*}
	$0
\end{align*}
endsnippet

context "math()"
snippet tag "tag" iA
\tag{$1}$0
endsnippet

context "math()"
snippet gcd "greatest common divisor" iA
\gcd($1)$0
endsnippet

context "math()"
snippet mod "modulo" iA
\Mod{$1}$0
endsnippet

snippet boxed "box around equation" iA
\boxed{$1}$0
endsnippet

snippet ali "Align" bA
\begin{align*}
	${1:${VISUAL}}
\end{align*}
endsnippet

snippet tali "Align" bA
\begin{align*}
	$1 && $2
\end{align*}
endsnippet

snippet gather "Gather" bA
\begin{gather*}
	${1:${VISUAL}}
\end{gather*}
endsnippet

snippet ar "Array" b
\begin{array*}{${1:rl}}
	${2:} &= $3\\\\
\end{array*}
endsnippet

snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

snippet f/ "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

priority 1000
snippet '((\d+)?(\\)?([A-Za-z]+)(\^((\{\d+\})|(\d)))?)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

priority 10
snippet '(\d+)/' "number frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

context "math()"
snippet '([A-Za-z])\d(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet sympy "sympyblock " w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet


#      _/_/_/                            _/                  _/
#   _/        _/    _/  _/_/_/  _/_/    _/_/_/      _/_/    _/    _/_/_/
#    _/_/    _/    _/  _/    _/    _/  _/    _/  _/    _/  _/  _/_/
#       _/  _/    _/  _/    _/    _/  _/    _/  _/    _/  _/      _/_/
#_/_/_/      _/_/_/  _/    _/    _/  _/_/_/      _/_/    _/  _/_/_/
#               _/
#          _/_/
# SYMBOLS

context "math()"
snippet ... "\ldots" iA
\ldots
endsnippet

context "math()"
snippet dots "Smart Dots" iA
\dots${1:commas, binary, multiplication}$0
endsnippet

context "math()"
snippet == "equals" iA
&=$1\\\\
endsnippet

context "math()"
snippet != "equals" iA
\neq
endsnippet

context "math()"
snippet ~= "approx equals" iA
\approx
endsnippet

context "math()"
snippet => "implies" A
\implies
endsnippet

context "math()"
snippet ~> "squiggley arrow" A
\rightsquigarrow
endsnippet

context "math()"
snippet bimp "bi-conditional" Ai
\Leftrightarrow
endsnippet

context "math()"
snippet vep "var epsilon" iA
\varepsilon
endsnippet

context "math()"
snippet pi "pi" iA
\pi $0
endsnippet

context "math()"
snippet alpha "alpha" iA
\alpha $0
endsnippet

context "math()"
snippet beta "beta" iA
\beta $0
endsnippet

context "math()"
snippet gamma "gamma" iA
\gamma $0
endsnippet

context "math()"
snippet delta "delta" iA
\delta $0
endsnippet

context "math()"
snippet theta "theta" iA
\theta $0
endsnippet

context "math()"
snippet && "AND" iA
\land
endsnippet

context "math()"
snippet ~ "NOT" i
\neg
endsnippet

context "math()"
snippet xor "XOR" iA
\oplus
endsnippet

context "math()"
snippet VV "OR" iA
\lor
endsnippet

context "math()"
snippet predi "predicate" iA
$1($2): \`\` $3 "\text{, where } $2 \in $4$0
endsnippet

context "math()"
snippet st "such that" iA
\text{ s.t. }
endsnippet

snippet l.c. "Linear Combination" iA
linear combination
endsnippet

context "math()"
snippet txt "text" iA
\text{ $1 }$0
endsnippet

context "math()"
snippet iff "iff" Ai
\iff
endsnippet

context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil $0
endsnippet

context "math()"
snippet bceil "ceil" iA
\bigl\lceil $1 \bigr\rceil $0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet

context "math()"
pre_expand "create_matrix(snip)"
snippet "(small|[gbBpvV])?mat(rix)?(\d+)x(\d+)" "Generate (small|[bBpvV])?matrix of *rows* by *columns*" br
endsnippet

context "math()"
pre_expand "create_inline_matrix(snip)"
snippet "(small|[gbBpvV])?imat(rix)?(\d+)x(\d+)" "Generate (small|[bBpvV])?matrix of *rows* by *columns*" ir
endsnippet

context "math()"
pre_expand "test(snip)"
snippet "(small|[gbBpvV])?ghp(rix)?(\d+)x(\d+)" "Generate (small|[bBpvV])?matrix of *rows* by *columns*" ir
endsnippet

#context "math()"
#snippet smart "Smart Matrix"
#	${1: text} 
#	`!p snip.rv=matrix_creator(t[1])`
#endsnippet

context "math()"
snippet qmat "Quick Matrix" iA
\mat{$1}$0
endsnippet

context "math()"
snippet 3mat "3 by 1 Matrix" iA
\mat{ $1 \\\\ $2 \\\\ $3 }$0
endsnippet

context "math()"
snippet 3rmat "1 by 3 Row Matrix" iA
\mat{ $1 & $2 & $3 }$0
endsnippet

context "math()"
snippet 2mat "2 by 1 Matrix" iA
\mat{ $1 \\\\ $2 }$0
endsnippet

context "math()"
snippet 2rmat "1 by 2 Row Matrix" iA
\mat{ $1 & $2}$0
endsnippet

context "math()"
snippet rops "Start Row Operation" iA
\rowops
endsnippet

context "math()"
snippet radd "Add rows" iA
\add[$1]{$2}{$3}
endsnippet

context "math()"
snippet rmult "Multiply row" iA
\mult{$2}{\cdot $3}$0
endsnippet

context "math()"
snippet rswap "Swap rows" iA
\swap{$1}{$2}$0
endsnippet

context "math()"
snippet seq "sequence" w
\left \\{ a _ { n } \right \\} _ { n = 0 } ^ \infty
endsnippet

context "math()"
snippet dint "integral" w
\int_{${1:-\infty}}^{${2:\infty}} ${3:${VISUAL}}\: d${4:x} $0
endsnippet

context "math()"
snippet int "integral" w
\int ${1:${VISUAL}}\: d${2:x} $0
endsnippet

context "math()"
snippet sum "sum" w
\sum_{${1:i}=${2:0}}^{${3:n}} ${4:${VISUAL}} $0
endsnippet

context "math()"
snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

context "math()"
snippet lim "limit" w
\lim_{${1:n}\to${2:\infty}}
endsnippet

context "math()"
snippet log "logarthm" w
\log_{${1:n}} $0
endsnippet

context "math()"
snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet


context "math()"
snippet ddx "d/dx" wA
\frac{d${1:}}{dx} $0
endsnippet

context "math()"
snippet ddt "d/dt" wA
\frac{d${1:}}{dt} $0
endsnippet

context "math()"
snippet part "d/dx" w
\frac{\partial ${1:}}{\partial ${2:x}} $0
endsnippet

# snippet dd "partial" wA
# \ddot{$1}$0
# endsnippet

context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet sr "^2" iA
^2
endsnippet

context "math()"
snippet cb "^3" iA
^3
endsnippet

context "math()"
snippet TT "to the ... power" iA
^{$1}$0
endsnippet

context "math()"
snippet __ "subscript" iA
_{$1}$0
endsnippet

context "math()"
snippet ooo "\infty" iA
\infty
endsnippet

context "math()"
snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

context "math()"
snippet <= "leq" iA
\le
endsnippet

context "math()"
snippet >= "geq" iA
\ge
endsnippet

context "math()"
snippet e= "congruent/equiv" iA
\equiv
endsnippet

context "math()"
snippet EE "geq" iA
\exists $1 \in $0
endsnippet

context "math()"
snippet AA "forall" iA
\forall $1 \in $0
endsnippet

#o                 o         o
#|                 | /       |
#O-o  o-o  oo  o-o OO   o-o -o- o-o
#|  | |   | | |    | \  |-'  |   \
#o-o  o   o-o- o-o o  o o-o  o  o-o
# BRACKETS

context "math()"
snippet obrace "overbrace" iA
\overbrace{$1}^{$2}$0
endsnippet

context "math()"
snippet ubrace "underbrace" iA
\underbrace{$1}_{$2}$0
endsnippet

context "math()"
snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right)$0
endsnippet

context "math()"
snippet [] "left[ right]" iA
\left[ ${1:${VISUAL}} \right]$0
endsnippet

context "math()"
snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right)$0
endsnippet

context "math()"
snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right)$0
endsnippet

context "math()"
snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right|$0
endsnippet

context "math()"
snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\}$0
endsnippet

context "math()"
snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\}$0
endsnippet

context "math()"
snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right]$0
endsnippet

context "math()"
snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet

context "math()"
# snippet conj "conjugate" iA
# \overline{$1}$0
# endsnippet



#        .                     .
#,-. . . |-. ,-. ,-. ,-. . ,-. |- ,-.
#`-. | | | | `-. |   |   | | | |  `-.
#`-' `-^ ^-' `-' `-' '   ' |-' `' `-'
#                          |
#                          '
# SUBSCRIPTS

context "math()"
snippet xnn "xn" iA
x_{n}
endsnippet

context "math()"
snippet ynn "yn" iA
y_{n}
endsnippet

context "math()"
snippet xii "xi" iA
x_{i}
endsnippet

context "math()"
snippet yii "yi" iA
y_{i}
endsnippet

context "math()"
snippet xjj "xj" iA
x_{j}
endsnippet

context "math()"
snippet yjj "yj" iA
y_{j}
endsnippet

context "math()"
snippet xp1 "x" iA
x_{n+1}
endsnippet

context "math()"
snippet n0 "x" iA
n_{0}
endsnippet

context "math()"
snippet xmm "x" iA
x_{m}
endsnippet

#                       /$$
#                      | $$
#  /$$$$$$$  /$$$$$$  /$$$$$$   /$$$$$$$
# /$$_____/ /$$__  $$|_  $$_/  /$$_____/
#|  $$$$$$ | $$$$$$$$  | $$   |  $$$$$$
# \____  $$| $$_____/  | $$ /$$\____  $$
# /$$$$$$$/|  $$$$$$$  |  $$$$//$$$$$$$/
#|_______/  \_______/   \___/ |_______/
#SETS

context "math()"
snippet afa "afa" iA
\mathbb{A}
endsnippet

context "math()"
snippet EU "E" iA
\qathbb{E}
endsnippet

context "math()"
snippet R0+ "R0+" iA
\\R_0^+
endsnippet

context "math()"
snippet Rp "Real Positive" iA
\mathbb{R^+}
endsnippet

snippet plot "Plot" w
\begin{figure}[$1]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xmin= ${2:-10}, xmax= ${3:10},
			ymin= ${4:-10}, ymax = ${5:10},
			axis lines = middle,
		]
			\addplot[domain=$2:$3, samples=${6:100}]{$7};
		\end{axis}
	\end{tikzpicture}
	\caption{$8}
	\label{${9:$8}}
\end{figure}
endsnippet

snippet nn "Tikz node" w
\node[$5] (${1/[^0-9a-zA-Z]//g}${2}) ${3:at (${4:0,0}) }{$${1}$};
$0
endsnippet

# snippet dr "Tikz draw" w
# \draw[${1}] (${2:0, 0}) -- $4(${3:0,0});
# $0
# endsnippet

snippet na "Tikz node above" w
node[above`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nb "Tikz node below" w
node[below`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nr "Tikz node right" w
node[right`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nl "Tikz node left" w
node[left`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nar "Tikz node above right" w
node[above right`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nal "Tikz node above left" w
node[above left`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nbr "Tikz node below right" w
node[below right`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet nbl "Tikz node below left" w
node[below left`!p snip.rv=', ' if t[2] else ''`${2}]{$${1}$} $0
endsnippet

snippet frame "Tikz frame" w
\draw[help lines, <->] (-$1, 0) -- ($1, 0);
\draw[help lines, <->] (0, -$1) -- (0, $1);
$0
endsnippet

snippet force "Tikz force" w
\draw[force] (${1:0, 0}) -- $3 ++(${2:0, 0});
$0
endsnippet

snippet tikz "Tikz" w
\begin{figure}[htb]
	\centering
	\begin{tikzpicture}
		$0
	\end{tikzpicture}
	\caption{$1}
	\label{fig:${2:${1/\\\w+\{(.*?)\}|\\(.)|(\w+)|([^\w\\]+)/(?4:_:\L$1$2$3\E)/ga}}}
\end{figure}
endsnippet


snippet co "Tikz coordinate" w
coordinate ($1)$0
endsnippet

context "math()"
snippet vv "Vector" iA
\vec{$1}$0
endsnippet

context "math()"
snippet bv "Basis Vector" iA
\left[ $1 \right]_{\mathcal{$2}}$0
endsnippet

context "math()"
snippet comp "Comp" iA
\mathit{comp}_{$1} {$2} $0
endsnippet

context "math()"
snippet proj "Projection" iA
\mathit{proj}_{$1} {$2} $0
endsnippet

context "math()"
snippet span "Span" iA
\mathit{span} {$1} $0
endsnippet

context "math()"
snippet e1 "Basis" iA
\vec{e_1}
endsnippet

context "math()"
snippet e2 "Basis" iA
\vec{e_2}
endsnippet

snippet mcal "mathcal" iA
\mathcal{$1}$0
endsnippet

# snippet unit "unit vector" iA
# \vec e_{$1}$0
# endsnippet

context "math()"
snippet lll "l" iA
\ell
endsnippet

context "math()"
snippet nabl "nabla" iA
\nabla
endsnippet

context "math()"
snippet xx "cross" iA
\times
endsnippet

context "math()"
snippet ** "cdot" iA
\cdot
endsnippet

snippet slide "slide" bA
\begin{slide}{$1}
    $0
\end{slide}
endsnippet

snippet '(?<!\\)formule' "formule" rwA
\formule{$1}{$2}$0
endsnippet

context "math()"
snippet norm "norm" iA
\left\Vert $1 \right\Vert$0
endsnippet

context "math()"
snippet abs "absolute" iA
\left| $1 \right|$0
endsnippet

#  __      _
# / /_____(_)__ _
#/ __/ __/ / _ `/
#\__/_/ /_/\_, /
#         /___/

snippet '(?<!\\)arcsin' "sin" rwA
\arcsin$1{${2:\theta}}$0
endsnippet
snippet '(?<!arc)(?<!\\)sine' "sine" rwA
\sin$1{${2:\theta}}$0
endsnippet
snippet '(?<!\\)arccos' "cos" rwA
\arccos$1{${2:\theta}}$0
endsnippet
snippet '(?<!arc)(?<!\\)cos' "cos" rwA
\cos$1{${2:\theta}}$0
endsnippet
snippet '(?<!\\)arctan' "tan" rwA
\arctan$1{${2:\theta}}$0
endsnippet
# snippet '(?<!arc)(?<!\\)tan' "tan" rwA
# \tan
# endsnippet
snippet '(?<!\\)arccot' "cot" rwA
\arccot$1{${2:\theta}}$0
endsnippet
snippet '(?<!arc)(?<!\\)cot' "cot" rwA
\cot$1{${2:\theta}}$0
endsnippet
snippet '(?<!\\)arccsc' "csc" rwA
\arccsc$1{${2:\theta}}$0
endsnippet
snippet '(?<!arc)(?<!\\)csc' "csc" rwA
\csc$1{${2:\theta}}$0
endsnippet
snippet '(?<!\\)arcsec' "sec" rwA
\arcsec$1{${2:\theta}}$0
endsnippet
# snippet '(?<!arc)(?<!\\)sec' "sec" rwA
# \sec
# endsnippet

context "math()"
snippet '(?<!\\)ln' "ln" rwA
\ln($1)$0
endsnippet

snippet '(?<!\\)exp' "exp" rw
\exp
endsnippet


snippet '(?<!\\)logo' "logo" rwA
\log
endsnippet

context "math()"
snippet -> "to" iA
\to
endsnippet

context "math()"
snippet !> "mapsto" iA
\mapsto
endsnippet

context "math()"
snippet r> "right arrow" iA
\rightarrow
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet

context "math()"
snippet CC "kromme" iA
\C
endsnippet

context "math()"
snippet bO "Big Oh- Notation" w
\mathcal{O}($1)$0
endsnippet

context "math()"
snippet Big-Oh "Big Oh Definition" w
\exists c, n_{0} \in \mathbb{R^+} \text{ s.t. } \forall n \in \mathbb{N}, n \ge n_{0} \implies $1 \le c \cdot $2
endsnippet

context "math()"
snippet BOM "Big Omega" w
\Omega($1)$0
endsnippet

context "math()"
snippet LL "laplace" iA
\mathcal{L}
endsnippet

context "math()"
snippet HH "hamiltonian" iA
\mathcal{H}
endsnippet

context "math()"
snippet FF "overdekking" iA
\mathcal{F}
endsnippet

context "math()"
snippet \\\ "setminus" iA
\setminus
endsnippet

context "math()"
snippet >> ">>" iA
\gg
endsnippet

context "math()"
snippet << "<<" iA
\ll
endsnippet

context "math()"
snippet DD "delta" iA
\Delta
endsnippet

context "math()"
snippet ~~ "~" iA
\sim
endsnippet

context "math()"
snippet star "star" iA
^\star
endsnippet

context "math()"
snippet set "set" iA
\\left\\{ $1 \\right\\}$0
endsnippet

context "math()"
snippet pwr "Power set" iA
\mathcal{P}($1)$0
endsnippet

context "math()"
snippet || "mid" iA
\mid
endsnippet

context "math()"
snippet t. "therefore" iA
\therefore
endsnippet

context "math()"
snippet n| "nmid" iA
\nmid
endsnippet

context "math()"
snippet cc "subset" iA
\subseteq
endsnippet

context "math()"
snippet c= "subset equal" iA
\subseteq
endsnippet

context "math()"
snippet bol "bol" i
\left(${1:x} - ${2:\delta}, $1 + $2\right)$0
endsnippet

context "math()"
snippet inwend "mathring" i
\mathring
endsnippet

context "math()"
snippet sluit "overline" i
\overline{$1}$0
endsnippet

context "math()"
snippet notin "not in " iA
\not\in
endsnippet

context "math()"
snippet inn "in " iA
\in
endsnippet

context "math()"
snippet fun "function" iA
${1:f} : $2 \to $3 
endsnippet

context "math()"
snippet ff "function at x" iA
${1:f}(${2:x})$0
endsnippet

context "math()"
snippet fog "function composition" i
${1:f} \circ ${2:g}$0
endsnippet

context "math()"
snippet surj "surjective" iA
\forall y \in ${1:CD}, \exists x \in ${2:D} \text{ s.t. } y = ${3:f}(x)$0
endsnippet

context "math()"
snippet inj "injective" iA
\forall x_1, x_2 \in ${1:D}, ${2:f}(x_1) = ${3:f}(x_2) \implies x_1 = x_2$0
endsnippet

context "math()"
snippet NN "n" iA
\mathbb{N}
endsnippet

context "math()"
snippet Nn "cap" iA
\cap
endsnippet

context "math()"
snippet UU "cup" iA
\cup
endsnippet

context "math()"
snippet OO "emptyset" iA
\emptyset
endsnippet

context "math()"
snippet RR "real" iA
\mathbb{R}
endsnippet

context "math()"
snippet RPn "Projective space" iA
\mathbb{R \mathrm P^n}
endsnippet

context "math()"
snippet QQ "Q" iA
\mathbb{Q}
endsnippet

context "math()"
snippet ZZ "Z" iA
\mathbb{Z}
endsnippet

context "math()"
snippet Zp "Z" iA
\mathbb{Z ^ +}
endsnippet
context "math()"
# snippet opn "U" iA
# \mathcal U
# endsnippet

context "math()"
snippet bbb "borel" iA
\mathcal B
endsnippet

context "math()"
snippet BB "Bezier" iA
B_{${1:i}}^{${2:n}}(${3:t})$0
endsnippet

# snippet NN "Basespline" iA
# N_{${1:i}, ${2:k+1}}(${3:u})$0
# endsnippet

#snippet dd "debohr" wA
#\vec d_{${1:i}}
#endsnippet

context "math()"
snippet l_2n "l2n" iA
\ell^2(\N)
endsnippet

context "math()"
snippet perp "perp" iA
\perp
endsnippet

context "math()"
snippet <! "normal" iA
\triangleleft
endsnippet

context "math()"
snippet <> "hokje" iA
\diamond
endsnippet

context "math()"
snippet sts "text subscript" iA
_\text{$1} $0
endsnippet

context "math()"
snippet bf "text bf" iA
\textbf{$1} $0
endsnippet

context "math()"
snippet tit "italicized text ;)" iA
\mathit{$1} $0
endsnippet

context "math()"
snippet mit "math it" iA
\mathit{$1} $0
endsnippet

context "math()"
snippet aca "group action" iA
{}^{$1}$0
endsnippet

context "math()"
snippet dag "dag" bA
\dag{`date +'%A %0d %B' | sed 's/.*/\u&/'`}

$0
endsnippet

context "math()"
snippet uur "uur" i
\uur{`date +'%H:%M'`}
endsnippet

context "math()"
snippet drm "drawmatrix" iA
\drawmatrix[$2]{$1} $0
endsnippet

# vim:ft=snippets
